// 尾调用: 一个函数的最后一个动作是调用函数
// 尾递归: 尾调用时最后一个函数是自己
// 尾调用优化: 如果当前栈帧上的局部变量等内容不需要再用了，当前栈帧经过适当的改变后可以直接作为被尾调用的函数的栈帧使用，然后程序可以跳到被尾调用的函数代码上
// 尾递归优化: 与尾调用一样 但尾递归优化要比尾调用简单的多 因为内容不变栈不变

function test1() {
    let a = 1
    test2()
}

function test2(n) {
    if (n < 2) return 2
    test2()
}

// 注意优点
// 一些编译器能对尾调用进行优化 以达到节省栈空间的目的
// 如第一个 在栈中 放test1函数的栈空间可以直接被test2覆盖后执行 即两个函数共用一个栈空间

/**
 * 1 并不是所有编译器都支持尾调用优化
 * 2 函数开辟栈空间是根据其内的变量等内容而定的
 * 3 如果支持优化 若尾函数栈空间需求别比调用它的函数大 则将原栈空间拉大(具有一定难度 所以对编译器要求较大)
 */